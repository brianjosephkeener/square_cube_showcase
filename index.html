<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Room Planner</title>
    <!-- Tailwind CSS for styling the UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling of the page */
        }
        #render-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none; /* Important for pointer events */
        }
        /* Style for the UI panels to float over the canvas */
        .ui-panel {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            max-width: 400px;
            margin: auto;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }
        #settings-panel {
            top: 1rem;
            right: 1rem;
            left: auto;
            bottom: auto;
            width: 200px;
        }
        /* Hides the selection panel by default */
        #selection-panel {
            transform: translateY(300%);
        }
        #selection-panel.visible {
            transform: translateY(0);
        }
        /* CSS for the collapsible panel functionality */
        .panel-content {
            max-height: 500px;
            margin-top: 0.75rem;
            opacity: 1;
            overflow: hidden;
            transition: all 0.4s ease-in-out;
        }
        .panel-collapsed .panel-content {
            max-height: 0;
            margin-top: 0;
            opacity: 0;
        }
        .toggle-panel-btn {
            transition: transform 0.4s ease-in-out;
        }
        .panel-collapsed .toggle-panel-btn {
            transform: rotate(-180deg);
        }
        /* Hide the actual file input */
        #texture-uploader {
            display: none;
        }
        /* Styles for the unit toggle */
        .unit-toggle button.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
        }
        .unit-toggle button {
            background-color: #374151; /* gray-700 */
            color: #d1d5db; /* gray-300 */
        }
        /* Custom styles for the snap toggle */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #4f46e5;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #4f46e5;
        }
    </style>
</head>
<body class="bg-gray-800">

    <!-- The canvas where the 3D scene will be rendered -->
    <canvas id="render-canvas"></canvas>

    <!-- Settings Panel (Top Right) -->
    <div id="settings-panel" class="p-2 bg-black bg-opacity-60 rounded-xl shadow-lg backdrop-blur-md border border-gray-600 text-white panel-collapsed">
        <div class="flex justify-between items-center cursor-pointer" onclick="toggleSettingsPanel()">
            <h2 class="text-md font-bold ml-2">Settings</h2>
            <button class="toggle-panel-btn p-1 rounded-full hover:bg-gray-700 focus:outline-none">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
            </button>
        </div>
        <div class="panel-content space-y-3">
            <div>
                <label for="grid-size" class="block text-sm text-center">Grid Size (ft)</label>
                <input type="number" id="grid-size" value="50" class="w-full p-2 mt-1 text-center bg-gray-700 border border-gray-500 rounded-lg">
            </div>
            <div class="flex items-center justify-between">
                <label for="snap-toggle" class="text-sm">Snap to Grid</label>
                <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                    <input type="checkbox" name="snap-toggle" id="snap-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                    <label for="snap-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                </div>
            </div>
            <button onclick="toggleTopDownView()" class="w-full p-2 font-semibold bg-cyan-600 text-white rounded-lg hover:bg-cyan-700">Top-Down View</button>
            <button onclick="clearAllObjects()" class="w-full p-2 font-bold bg-red-600 text-white rounded-lg hover:bg-red-700">Clear All</button>
        </div>
    </div>

    <!-- Main UI Panel for creating objects -->
    <div id="ui-panel-container" class="ui-panel p-4 bg-black bg-opacity-60 rounded-xl shadow-lg backdrop-blur-md border border-gray-600 text-white">
        <div class="flex justify-between items-center cursor-pointer" onclick="togglePanel()">
            <h1 class="text-xl font-bold">Create Object</h1>
            <button class="toggle-panel-btn p-1 rounded-full hover:bg-gray-700 focus:outline-none">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" /></svg>
            </button>
        </div>
        <div class="panel-content">
             <div class="flex justify-between items-center mb-2">
                <p class="font-semibold">Dimensions</p>
                <div class="unit-toggle flex rounded-lg p-0.5 bg-gray-800">
                    <button id="unit-ft" class="px-3 py-1 text-sm rounded-md active" onclick="setUnit('ft')">Feet</button>
                    <button id="unit-in" class="px-3 py-1 text-sm rounded-md" onclick="setUnit('in')">Inches</button>
                </div>
            </div>
            <div class="grid grid-cols-3 gap-2 mb-2">
                <input type="number" id="length" placeholder="Length" class="w-full p-2 text-center bg-gray-700 border border-gray-500 rounded-lg">
                <input type="number" id="width" placeholder="Width" class="w-full p-2 text-center bg-gray-700 border border-gray-500 rounded-lg">
                <input type="number" id="height" placeholder="Height" class="w-full p-2 text-center bg-gray-700 border border-gray-500 rounded-lg">
            </div>
            <button onclick="createCustomProduct()" class="w-full p-2 font-bold bg-yellow-500 text-black rounded-lg hover:bg-yellow-600">Create</button>
        </div>
    </div>

    <!-- Selection Panel for modifying a selected object -->
    <div id="selection-panel" class="ui-panel p-4 bg-gray-900 bg-opacity-70 rounded-xl shadow-lg backdrop-blur-md border border-gray-500 text-white">
        <h2 class="text-lg font-bold text-center mb-3">Edit Selected Object</h2>
        <div class="mb-3">
            <p class="text-sm font-medium text-center mb-1">Dimensions (ft)</p>
            <div class="grid grid-cols-3 gap-2">
                <input type="number" id="edit-length" placeholder="L" class="w-full p-2 text-center bg-gray-700 border border-gray-500 rounded-lg">
                <input type="number" id="edit-width" placeholder="W" class="w-full p-2 text-center bg-gray-700 border border-gray-500 rounded-lg">
                <input type="number" id="edit-height" placeholder="H" class="w-full p-2 text-center bg-gray-700 border border-gray-500 rounded-lg">
            </div>
        </div>
        <div class="grid grid-cols-2 gap-4 items-center mb-3">
            <div>
                <label for="color-picker" class="block text-sm font-medium text-center">Color</label>
                <input id="color-picker" type="color" value="#38bdf8" class="w-full h-10 p-1 bg-gray-700 border border-gray-500 rounded-lg cursor-pointer">
            </div>
            <div>
                <label for="transparency-slider" class="block text-sm font-medium text-center">Transparency</label>
                <input id="transparency-slider" type="range" min="0.1" max="1" step="0.1" value="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>
        <div class="mb-3">
             <label for="texture-uploader" class="w-full block p-2 text-center font-semibold bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 cursor-pointer">Upload Texture</label>
             <input type="file" id="texture-uploader" accept="image/*">
        </div>
        <div class="space-y-2">
            <p class="text-sm font-medium text-center">Rotation (degrees)</p>
            <div class="flex items-center gap-2">
                <label class="w-4 text-center font-mono text-red-400">X</label>
                <input id="rotation-input-x" type="number" min="0" max="360" value="0" class="flex-grow p-1 text-center bg-gray-700 border border-gray-500 rounded-lg">
            </div>
            <div class="flex items-center gap-2">
                <label class="w-4 text-center font-mono text-green-400">Y</label>
                <input id="rotation-input-y" type="number" min="0" max="360" value="0" class="flex-grow p-1 text-center bg-gray-700 border border-gray-500 rounded-lg">
            </div>
        </div>
        <button onclick="deleteSelectedProduct()" class="w-full mt-4 p-2 font-bold bg-red-600 text-white rounded-lg hover:bg-red-700">Delete</button>
    </div>

    <!-- Three.js library and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // === SCENE SETUP ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2d3748);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('render-canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // === CAMERA & CONTROLS ===
        const initialCameraPosition = new THREE.Vector3(15, 20, 25);
        camera.position.copy(initialCameraPosition);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2;

        // === LIGHTING ===
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 15);
        scene.add(dirLight);

        // === ROOM & INTERACTION HELPERS ===
        let roomSize = 50;
        let gridHelper = new THREE.GridHelper(roomSize, roomSize);
        scene.add(gridHelper);
        const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // === STATE MANAGEMENT ===
        let products = [];
        let selectedProduct = null;
        let isDragging = false;
        let selectionOutline;
        const textureLoader = new THREE.TextureLoader();
        let currentUnit = 'ft';
        let isSnappingEnabled = false;
        let isTopDownView = false;
        
        let dragStartTime;
        let pointerDownPosition = new THREE.Vector2();
        let lastTap = 0;
        let lastTappedObject = null;

        // === UI ELEMENTS ===
        const selectionPanel = document.getElementById('selection-panel');
        const colorPicker = document.getElementById('color-picker');
        const transparencySlider = document.getElementById('transparency-slider');
        const rotationInputs = { x: document.getElementById('rotation-input-x'), y: document.getElementById('rotation-input-y') };
        const dimensionInputs = { l: document.getElementById('edit-length'), w: document.getElementById('edit-width'), h: document.getElementById('edit-height') };
        const gridSizeInput = document.getElementById('grid-size');
        const textureUploader = document.getElementById('texture-uploader');
        const unitFtBtn = document.getElementById('unit-ft');
        const unitInBtn = document.getElementById('unit-in');
        const snapToggle = document.getElementById('snap-toggle');

        // === CORE FUNCTIONS ===
        window.createCustomProduct = () => {
            const lengthInput = document.getElementById('length');
            const widthInput = document.getElementById('width');
            const heightInput = document.getElementById('height');

            if (!lengthInput.value || !widthInput.value || !heightInput.value) {
                console.log("All dimension fields are required.");
                return;
            }

            let l = parseFloat(lengthInput.value);
            let w = parseFloat(widthInput.value);
            let h = parseFloat(heightInput.value);

            if (currentUnit === 'in') {
                l /= 12; w /= 12; h /= 12;
            }
            
            if (h <= 0) h = 0.01; if (w <= 0) w = 0.01; if (l <= 0) l = 0.01;

            createProduct(l, h, w);
        };

        function createProduct(length, height, width) {
            const geometry = new THREE.BoxGeometry(length, height, width);
            const material = new THREE.MeshStandardMaterial({ color: 0x38bdf8, transparent: true, opacity: 1 });
            const product = new THREE.Mesh(geometry, material);
            product.position.y = height / 2;
            scene.add(product);
            products.push(product);
        }

        function selectProduct(product) {
            if (selectedProduct && selectedProduct !== product) {
                deselectProduct();
            }
            
            if (!selectedProduct) {
                selectedProduct = product;
                const edges = new THREE.EdgesGeometry(product.geometry);
                selectionOutline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 4 }));
                scene.add(selectionOutline);
                updateSelectionOutline();
            }
        }

        function deselectProduct() {
            if (selectionOutline) scene.remove(selectionOutline);
            selectedProduct = null;
            selectionOutline = null;
            lastTappedObject = null;
            selectionPanel.classList.remove('visible');
        }

        window.deleteSelectedProduct = () => {
            if (!selectedProduct) return;
            scene.remove(selectedProduct);
            products = products.filter(p => p !== selectedProduct);
            deselectProduct();
        };

        window.clearAllObjects = () => {
            deselectProduct();
            products.forEach(p => scene.remove(p));
            products = [];
        };
        
        // === UI Event Listeners & Updaters ===
        window.setUnit = (unit) => {
            currentUnit = unit;
            unitFtBtn.classList.toggle('active', unit === 'ft');
            unitInBtn.classList.toggle('active', unit === 'in');
        };
        
        window.toggleTopDownView = () => {
            isTopDownView = !isTopDownView;
            if (isTopDownView) {
                controls.enableRotate = false;
                camera.position.set(0, 40, 0);
            } else {
                controls.enableRotate = true;
                camera.position.copy(initialCameraPosition);
            }
            controls.target.set(0, 0, 0);
        };

        snapToggle.addEventListener('change', (e) => {
            isSnappingEnabled = e.target.checked;
        });

        colorPicker.addEventListener('input', (e) => {
            if (selectedProduct) {
                selectedProduct.material.map = null;
                selectedProduct.material.color.set(e.target.value);
            }
        });

        transparencySlider.addEventListener('input', (e) => {
            if (selectedProduct) selectedProduct.material.opacity = parseFloat(e.target.value);
        });

        rotationInputs.x.addEventListener('input', (e) => updateRotation('x', parseFloat(e.target.value)));
        rotationInputs.y.addEventListener('input', (e) => updateRotation('y', parseFloat(e.target.value)));
        
        dimensionInputs.l.addEventListener('input', updateDimensions);
        dimensionInputs.w.addEventListener('input', updateDimensions);
        dimensionInputs.h.addEventListener('input', updateDimensions);

        gridSizeInput.addEventListener('input', (e) => {
            const newSize = parseInt(e.target.value) || 50;
            updateGrid(newSize);
        });
        
        textureUploader.addEventListener('change', (e) => {
            if (!selectedProduct || !e.target.files || e.target.files.length === 0) return;
            const file = e.target.files[0];
            const url = URL.createObjectURL(file);
            textureLoader.load(url, (texture) => {
                selectedProduct.material.map = texture;
                selectedProduct.material.needsUpdate = true;
                URL.revokeObjectURL(url);
            });
        });

        function updateRotation(axis, degrees) {
            if (selectedProduct) {
                const radians = THREE.MathUtils.degToRad(degrees);
                selectedProduct.rotation[axis] = radians;
                updateSelectionOutline();
            }
        }
        
        function updateDimensions() {
            if (!selectedProduct) return;
            let l = parseFloat(dimensionInputs.l.value);
            let w = parseFloat(dimensionInputs.w.value);
            let h = parseFloat(dimensionInputs.h.value);
            
            if (h <= 0) h = 0.01; if (w <= 0) w = 0.01; if (l <= 0) l = 0.01;

            selectedProduct.geometry.dispose();
            selectedProduct.geometry = new THREE.BoxGeometry(l, h, w);
            selectedProduct.position.y = h / 2;

            selectionOutline.geometry.dispose();
            selectionOutline.geometry = new THREE.EdgesGeometry(selectedProduct.geometry);
            updateSelectionOutline();
        }

        function updateUIForSelection() {
            if (!selectedProduct) return;
            colorPicker.value = '#' + selectedProduct.material.color.getHexString();
            transparencySlider.value = selectedProduct.material.opacity;
            rotationInputs.x.value = Math.round(THREE.MathUtils.radToDeg(selectedProduct.rotation.x));
            rotationInputs.y.value = Math.round(THREE.MathUtils.radToDeg(selectedProduct.rotation.y));
            dimensionInputs.l.value = selectedProduct.geometry.parameters.width;
            dimensionInputs.w.value = selectedProduct.geometry.parameters.depth;
            dimensionInputs.h.value = selectedProduct.geometry.parameters.height;
        }
        
        function updateGrid(newSize) {
            roomSize = newSize;
            scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(roomSize, roomSize);
            scene.add(gridHelper);
        }

        function updateSelectionOutline() {
            if (selectionOutline && selectedProduct) {
                selectionOutline.position.copy(selectedProduct.position);
                selectionOutline.rotation.copy(selectedProduct.rotation);
                selectionOutline.scale.copy(selectedProduct.scale);
            }
        }

        // === POINTER (TOUCH/MOUSE) EVENT LISTENERS ===
        function onPointerDown(event) {
            if (event.target.closest('.ui-panel')) return;

            updatePointer(event);
            pointerDownPosition.copy(pointer);
            dragStartTime = Date.now();

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(products);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                if (clickedObject !== selectedProduct) {
                    selectProduct(clickedObject);
                }
                isDragging = true;
                controls.enabled = false;
            } else {
                deselectProduct();
            }
        }

        function onPointerMove(event) {
            if (!isDragging || !selectedProduct) return;

            updatePointer(event);
            raycaster.setFromCamera(pointer, camera);
            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(floorPlane, intersectionPoint);

            let newX = intersectionPoint.x;
            let newZ = intersectionPoint.z;

            if (isSnappingEnabled) {
                newX = Math.round(newX);
                newZ = Math.round(newZ);
            }

            const halfSize = roomSize / 2;
            selectedProduct.position.x = Math.max(-halfSize, Math.min(halfSize, newX));
            selectedProduct.position.z = Math.max(-halfSize, Math.min(halfSize, newZ));
            
            updateSelectionOutline();
        }

        function onPointerUp(event) {
            const wasDragging = isDragging;
            isDragging = false;
            controls.enabled = true;

            if (!wasDragging || !selectedProduct) return;

            const dragDuration = Date.now() - dragStartTime;
            updatePointer(event);
            const dragDistance = pointer.distanceTo(pointerDownPosition);

            if (dragDuration < 200 && dragDistance < 0.05) {
                const currentTime = Date.now();
                const timeSinceLastTap = currentTime - lastTap;

                if (timeSinceLastTap < 300 && selectedProduct === lastTappedObject) {
                    updateUIForSelection();
                    selectionPanel.classList.add('visible');
                    lastTap = 0;
                    lastTappedObject = null;
                } else {
                    selectionPanel.classList.remove('visible');
                    lastTap = currentTime;
                    lastTappedObject = selectedProduct;
                }
            }
        }

        function updatePointer(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            const touch = event.touches ? event.touches[0] : event;
            pointer.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
        }

        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerup', onPointerUp);

        // === Misc UI and Window Handling ===
        window.togglePanel = () => document.getElementById('ui-panel-container').classList.toggle('panel-collapsed');
        window.toggleSettingsPanel = () => document.getElementById('settings-panel').classList.toggle('panel-collapsed');
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // === RENDER LOOP ===
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
